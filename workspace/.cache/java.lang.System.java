 // Source code is unavailable, and was generated by the Fernflower decompiler.
package java.lang;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.Console;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.System.1;
import java.lang.System.2;
import java.lang.System.CallersHolder;
import java.lang.System.Logger;
import java.lang.System.LoggerFinder;
import java.lang.invoke.StringConcatFactory;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.nio.channels.Channel;
import java.nio.channels.spi.SelectorProvider;
import java.nio.charset.Charset;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.PropertyPermission;
import java.util.ResourceBundle;
import java.util.Map.Entry;
import jdk.internal.access.SharedSecrets;
import jdk.internal.logger.LazyLoggers;
import jdk.internal.misc.Unsafe;
import jdk.internal.misc.VM;
import jdk.internal.module.ModuleBootstrap;
import jdk.internal.reflect.CallerSensitive;
import jdk.internal.reflect.Reflection;
import jdk.internal.util.StaticProperty;
import jdk.internal.util.SystemProps;
import jdk.internal.vm.annotation.IntrinsicCandidate;
import jdk.internal.vm.annotation.Stable;
import sun.nio.cs.UTF_8;
import sun.nio.fs.DefaultFileSystemProvider;

public final class System {
   public static final InputStream in;
   public static final PrintStream out;
   public static final PrintStream err;
   private static final int NEVER = 1;
   private static final int MAYBE = 2;
   @Stable
   private static int allowSecurityManager;
   private static volatile SecurityManager security;
   private static String notSupportedJnuEncoding;
   private static volatile Console cons;
   @Stable
   private static volatile PrintStream initialErrStream;
   private static Properties props;
   private static String lineSeparator;
   static ModuleLayer bootLayer;

   private static native void registerNatives();

   private static boolean allowSecurityManager() {
      return allowSecurityManager != 1;
   }

   public static void setIn(InputStream in) {
      checkIO();
      setIn0(in);
   }

   public static void setOut(PrintStream out) {
      checkIO();
      setOut0(out);
   }

   public static void setErr(PrintStream err) {
      checkIO();
      setErr0(err);
   }

   public static Console console() {
      Console c = cons;
      if (cons == null) {
         Class var1 = System.class;
         synchronized(System.class) {
            c = cons;
            if (cons == null) {
               cons = c = SharedSecrets.getJavaIOAccess().console();
            }
         }
      }

      return c;
   }

   public static Channel inheritedChannel() throws IOException {
      return SelectorProvider.provider().inheritedChannel();
   }

   private static void checkIO() {
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new RuntimePermission("setIO"));
      }

   }

   private static native void setIn0(InputStream var0);

   private static native void setOut0(PrintStream var0);

   private static native void setErr0(PrintStream var0);

   private static URL codeSource(Class<?> clazz) {
      Objects.requireNonNull(clazz);
      CodeSource cs = ((ProtectionDomain)AccessController.doPrivileged(clazz)).getCodeSource();
      return cs != null ? cs.getLocation() : null;
   }

   /** @deprecated */
   @Deprecated(
      since = "17",
      forRemoval = true
   )
   @CallerSensitive
   public static void setSecurityManager(SecurityManager sm) {
      if (allowSecurityManager()) {
         Class<?> callerClass = Reflection.getCallerClass();
         if (CallersHolder.callers.putIfAbsent(callerClass, true) == null) {
            URL url = codeSource(callerClass);
            String source;
            if (url == null) {
               source = callerClass.getName();
            } else {
               source = callerClass.getName() + " (" + url + ")";
            }

            initialErrStream.printf("WARNING: A terminally deprecated method in java.lang.System has been called\nWARNING: System::setSecurityManager has been called by %s\nWARNING: Please consider reporting this to the maintainers of %s\nWARNING: System::setSecurityManager will be removed in a future release\n", source, callerClass.getName());
         }

         implSetSecurityManager(sm);
      } else if (sm != null) {
         throw new UnsupportedOperationException("The Security Manager is deprecated and will be removed in a future release");
      }

   }

   private static void implSetSecurityManager(SecurityManager sm) {
      if (security == null) {
         Object.class.getResource("java/lang/ANY");
         DefaultFileSystemProvider.theFileSystem();
      }

      if (sm != null) {
         try {
            sm.checkPackageAccess("java.lang");
         } catch (Exception var2) {
            ;
         }
      }

      setSecurityManager0(sm);
   }

   private static synchronized void setSecurityManager0(SecurityManager s) {
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new RuntimePermission("setSecurityManager"));
      }

      if (s != null && s.getClass().getClassLoader() != null) {
         AccessController.doPrivileged(new 1(s));
      }

      security = s;
   }

   /** @deprecated */
   @Deprecated(
      since = "17",
      forRemoval = true
   )
   public static SecurityManager getSecurityManager() {
      return allowSecurityManager() ? security : null;
   }

   @IntrinsicCandidate
   public static native long currentTimeMillis();

   @IntrinsicCandidate
   public static native long nanoTime();

   @IntrinsicCandidate
   public static native void arraycopy(Object var0, int var1, Object var2, int var3, int var4);

   @IntrinsicCandidate
   public static native int identityHashCode(Object var0);

   public static Properties getProperties() {
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPropertiesAccess();
      }

      return props;
   }

   public static String lineSeparator() {
      return lineSeparator;
   }

   public static void setProperties(Properties props) {
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPropertiesAccess();
      }

      if (props == null) {
         Map<String, String> tempProps = SystemProps.initProperties();
         VersionProps.init(tempProps);
         props = createProperties(tempProps);
      }

      props = props;
   }

   public static String getProperty(String key) {
      checkKey(key);
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPropertyAccess(key);
      }

      return props.getProperty(key);
   }

   public static String getProperty(String key, String def) {
      checkKey(key);
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPropertyAccess(key);
      }

      return props.getProperty(key, def);
   }

   public static String setProperty(String key, String value) {
      checkKey(key);
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new PropertyPermission(key, "write"));
      }

      return (String)props.setProperty(key, value);
   }

   public static String clearProperty(String key) {
      checkKey(key);
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new PropertyPermission(key, "write"));
      }

      return (String)props.remove(key);
   }

   private static void checkKey(String key) {
      if (key == null) {
         throw new NullPointerException("key can't be null");
      } else if (key.isEmpty()) {
         throw new IllegalArgumentException("key can't be empty");
      }
   }

   public static String getenv(String name) {
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new RuntimePermission("getenv." + name));
      }

      return ProcessEnvironment.getenv(name);
   }

   public static Map<String, String> getenv() {
      SecurityManager sm = getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new RuntimePermission("getenv.*"));
      }

      return ProcessEnvironment.getenv();
   }

   @CallerSensitive
   public static Logger getLogger(String name) {
      Objects.requireNonNull(name);
      Class<?> caller = Reflection.getCallerClass();
      if (caller == null) {
         throw new IllegalCallerException("no caller frame");
      } else {
         return LazyLoggers.getLogger(name, caller.getModule());
      }
   }

   @CallerSensitive
   public static Logger getLogger(String name, ResourceBundle bundle) {
      ResourceBundle rb = (ResourceBundle)Objects.requireNonNull(bundle);
      Objects.requireNonNull(name);
      Class<?> caller = Reflection.getCallerClass();
      if (caller == null) {
         throw new IllegalCallerException("no caller frame");
      } else {
         SecurityManager sm = getSecurityManager();
         return sm != null ? (Logger)AccessController.doPrivileged(caller, (AccessControlContext)null, LoggerFinder.LOGGERFINDER_PERMISSION) : LoggerFinder.accessProvider().getLocalizedLogger(name, rb, caller.getModule());
      }
   }

   public static void exit(int status) {
      Runtime.getRuntime().exit(status);
   }

   public static void gc() {
      Runtime.getRuntime().gc();
   }

   /** @deprecated */
   @Deprecated(
      since = "18",
      forRemoval = true
   )
   public static void runFinalization() {
      Runtime.getRuntime().runFinalization();
   }

   @CallerSensitive
   public static void load(String filename) {
      Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);
   }

   @CallerSensitive
   public static void loadLibrary(String libname) {
      Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
   }

   public static native String mapLibraryName(String var0);

   private static PrintStream newPrintStream(OutputStream out, String enc) {
      return enc != null ? new PrintStream(new BufferedOutputStream(out, 128), true, Charset.forName(enc, UTF_8.INSTANCE)) : new PrintStream(new BufferedOutputStream(out, 128), true);
   }

   private static void logInitException(boolean printToStderr, boolean printStackTrace, String msg, Throwable e) {
      if (VM.initLevel() < 1) {
         throw new InternalError("system classes not initialized");
      } else {
         PrintStream log = printToStderr ? err : out;
         if (msg != null) {
            log.println(msg);
         }

         if (printStackTrace) {
            e.printStackTrace(log);
         } else {
            log.println(e);
            Throwable[] var5 = e.getSuppressed();
            int var6 = var5.length;

            for(int var7 = 0; var7 < var6; ++var7) {
               Throwable suppressed = var5[var7];
               log.println("Suppressed: " + suppressed);
            }

            Throwable cause = e.getCause();
            if (cause != null) {
               log.println("Caused by: " + cause);
            }
         }

      }
   }

   private static Properties createProperties(Map<String, String> initialProps) {
      Properties properties = new Properties(initialProps.size());
      Iterator var2 = initialProps.entrySet().iterator();

      while(var2.hasNext()) {
         Entry<String, String> entry = (Entry)var2.next();
         String prop = (String)entry.getKey();
         byte var6 = -1;
         switch(prop.hashCode()) {
         case -1594982994:
            if (prop.equals("jdk.boot.class.path.append")) {
               var6 = 4;
            }
            break;
         case -903405997:
            if (prop.equals("sun.nio.MaxDirectMemorySize")) {
               var6 = 0;
            }
            break;
         case -137219825:
            if (prop.equals("sun.java.launcher.diag")) {
               var6 = 3;
            }
            break;
         case 82382212:
            if (prop.equals("sun.nio.PageAlignDirectMemory")) {
               var6 = 1;
            }
            break;
         case 2006761672:
            if (prop.equals("java.lang.Integer.IntegerCache.high")) {
               var6 = 2;
            }
         }

         switch(var6) {
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
            break;
         default:
            properties.put(prop, entry.getValue());
         }
      }

      return properties;
   }

   private static void initPhase1() {
      setJavaLangAccess();
      Map<String, String> tempProps = SystemProps.initProperties();
      VersionProps.init(tempProps);
      VM.saveProperties(tempProps);
      props = createProperties(tempProps);
      String jnuEncoding = props.getProperty("sun.jnu.encoding");
      if (jnuEncoding == null || !Charset.isSupported(jnuEncoding)) {
         notSupportedJnuEncoding = jnuEncoding == null ? "null" : jnuEncoding;
         props.setProperty("sun.jnu.encoding", "UTF-8");
      }

      StaticProperty.javaHome();
      lineSeparator = props.getProperty("line.separator");
      FileInputStream fdIn = new FileInputStream(FileDescriptor.in);
      FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);
      FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);
      setIn0(new BufferedInputStream(fdIn));
      setOut0(newPrintStream(fdOut, props.getProperty("stdout.encoding")));
      setErr0(newPrintStream(fdErr, props.getProperty("stderr.encoding")));
      Terminator.setup();
      VM.initializeOSEnvironment();
      SharedSecrets.getJavaLangRefAccess().startThreads();
      VM.initLevel(1);
   }

   private static int initPhase2(boolean printToStderr, boolean printStackTrace) {
      try {
         bootLayer = ModuleBootstrap.boot();
      } catch (Error | Exception var3) {
         logInitException(printToStderr, printStackTrace, "Error occurred during initialization of boot layer", var3);
         return -1;
      }

      VM.initLevel(2);
      return 0;
   }

   private static void initPhase3() {
      Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);
      String smProp = getProperty("java.security.manager");
      boolean needWarning = false;
      if (smProp != null) {
         label65: {
            byte var3 = -1;
            switch(smProp.hashCode()) {
            case 0:
               if (smProp.equals("")) {
                  var3 = 2;
               }
               break;
            case 92906313:
               if (smProp.equals("allow")) {
                  var3 = 1;
               }
               break;
            case 271239035:
               if (smProp.equals("disallow")) {
                  var3 = 0;
               }
               break;
            case 1544803905:
               if (smProp.equals("default")) {
                  var3 = 3;
               }
            }

            switch(var3) {
            case 0:
               allowSecurityManager = 1;
               break label65;
            case 1:
               allowSecurityManager = 2;
               break label65;
            case 2:
            case 3:
               implSetSecurityManager(new SecurityManager());
               allowSecurityManager = 2;
               needWarning = true;
               break label65;
            }

            try {
               ClassLoader cl = ClassLoader.getBuiltinAppClassLoader();
               Class<?> c = Class.forName(smProp, false, cl);
               Constructor<?> ctor = c.getConstructor();
               if (!SecurityManager.class.isAssignableFrom(c) || !Modifier.isPublic(c.getModifiers()) || !Modifier.isPublic(ctor.getModifiers())) {
                  throw new Error("Could not create SecurityManager: " + ctor.toString());
               }

               ctor.setAccessible(true);
               SecurityManager sm = (SecurityManager)ctor.newInstance();
               implSetSecurityManager(sm);
               needWarning = true;
            } catch (Exception var8) {
               throw new InternalError("Could not create SecurityManager", var8);
            }

            allowSecurityManager = 2;
         }
      } else {
         allowSecurityManager = 1;
      }

      if (needWarning) {
         err.println("WARNING: A command line option has enabled the Security Manager\nWARNING: The Security Manager is deprecated and will be removed in a future release");
      }

      if (notSupportedJnuEncoding != null) {
         err.println("WARNING: The encoding of the underlying platform's file system is not supported: " + notSupportedJnuEncoding);
      }

      initialErrStream = err;
      VM.initLevel(3);
      ClassLoader scl = ClassLoader.initSystemClassLoader();
      Thread.currentThread().setContextClassLoader(scl);
      VM.initLevel(4);
   }

   private static void setJavaLangAccess() {
      SharedSecrets.setJavaLangAccess(new 2());
   }

   static {
      registerNatives();
      in = null;
      out = null;
      err = null;
   }
}
